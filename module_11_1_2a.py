""""
Задача.
Имеются файлы типа MS Excel с годовыми отчётами некой коммерческой медицинской организации по помесячному количеству
заключённых договоров в разрезе их типов:

        янв фев мар апр ....
  тип1  n11 n12 n13 n14 ...
  тип2  n21 n22 n23 n24 ...
   ...  ... ... ... ... ...
  ИТОГО T1 T2  T3  T4   ...

Необходимо собрать данные со всех имеющихся файлов по четырём типам договоров (ведение родов, ведение беременности, детские
и госпитализация). В результате надо получить четыре графика, по одному на каждый из четырёх типов договоров. Ось ординат - года,
ось абсцисс - суммарное количество заключенных договоров за весь период с января по последний месяц в самом "коротком"
отчёте.
("Самым коротким" может быть отчёт за текущий год, т.к. в нём в общем случае присутствуют данные только с января
по прошлый (полностью завершённый) месяц. Таким образом на графиках будет наглядно видна тенденция изменения количества
договоров за аналогичные периоды лет, представленных в отчётах.)

Файлы имеют наименования col_zakdogNNNN.xlsx, где NNNN - четырёхзначный номер года, за который представлен отчёт.
Количество файлов и годы, за которые представлены отчёты, заранее не известны, известно только, что медицинское
учреждение на рынке с 2011 года. Каждый отчёт лежит в первом рабочем листе книги Excel.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Комментарии разработчика (проблема уже неактуальна, но вопрос такой был!).
При внимательном изучении структуры исходных файлов видно, что данные начинаются не с первого столбца, первый
столбец пуст. В связи с этим много головной боли: метод pd.read_excel() не умеет пропускать столбцы, как
он это делает со строками, поэтому приходится "городить" двухуровневый индекс для грамотной обработки
наименований типов договоров. Поэтому индексы получаются не строковые, а определены в виде кортежей вида

        (NaN, '<тип договора>')

Как бы и ладно, если pd понимает такие индексы, так и пусть они в виде кортежей... Но после обработки всех файлов мне
нужен набор всевозможных типов договоров, которые только встречаются в отчётах, причём этот набор должен быть
уникальным. Вот тут-то и приходится мудрить: в случае с кортежами множество типа set не помогает исключить дубли -
ни один кортеж другому не равен...

Но, может, я какой-то секрет либо ещё не знаю, либо знаю, но не сообразил, как его для этой задачи применить.

Поэтому - ВОПРОС ПРОВЕРЯЮЩЕМУ, если он дочитал этот лонг-рид до этого места:
          ===================
Как можно и можно ли вообще дать понять pd.read_excel(), что первый столбец рабочего листа книги Excel вообще
игнорировать, а одноуровневый индекс собирать, начиная со второго столбца?

Ответ нашёл самостоятельно, даже два варианта, код переписал:
=============================================================
1. Можно в pd.read_excel() задать параметр usecols, в котором задать список (iterable) колонок, которые надо считывать
2. Можно указать, что не надо считывать те колонки, у которых нет заголовка. Для этого надо использовать специальное
   имя колонки = 'Unnamed' и использовать формулу:
        pd.read_excel(..., usecols=lambda x: 'Unnamed' not in x, index_col=0 )

"""

from datetime import datetime
import matplotlib.pyplot as plt
import pandas as pd
import pprint

YEAR_1ST = 2011  # Дата выхода организации на рынок

if __name__ == '__main__':
    dog_quantity = {}  # Словарь DataFrame'ов: ключ - год, данные - DataFrame, считанный из файла
    months = []  # Названия колонок
    dog_types = set([])  # Уникальный набор индексов строк данных (= типов договоров)
    year = YEAR_1ST  # Счётчик годов, начинается с первого года работы учреждения
    year_cur = datetime.now().year  # Текущий год - последний из возможных отчётных
    while year <= year_cur:
        try:
            with pd.ExcelFile(f'.\\Data\\col_zakdog{year}.xlsx') as xls:
                dog_quantity[year] = pd.read_excel(io=xls, sheet_name=xls.sheet_names[0], header=5
                                                   # Заголовок в 6-й строке (в строке 5, если считать от 0)
                                                   , usecols=lambda x: 'Unnamed' not in x,
                                                   index_col=0)  # и все колонки без заголовков
                # 'Unnamed' - это специальное псевдо-имя колонки, которое обозначает колонку без заголовка
            if len(months) == 0 or len(months) > len(
                    dog_quantity[year].columns):  # 1) len(months) == 0 -- условие инициализации индексов
                months = dog_quantity[year].columns  # 2) len(months) > len(...) -- это возможно только тогда, когда
                #   текущий файл - самый "короткий", тогда список
                #   используемых колонок берём из него
            dog_types = (dog_types
                         | set(dog_quantity[year].index))  # Добавляем все индексы из текущего файла -- вдруг какой-то новый тип договора
            #   в нём добавился. set() делает этот список уникальным.
        except FileNotFoundError:
            pass  # Файл за любой год может отсутствовать - это нормально
        finally:
            year += 1  # В любом случае - проверим следующий год

# Усечём DF по самому короткому году, исключив строку "ИТОГО"
for year in dog_quantity.keys():
    dog_quantity[year] = dog_quantity[year].loc[
        [dog_type for dog_type in dog_quantity[year].index if dog_type != 'ИТОГО'], months]

diag_full = {}  # DFs for diagrams - если графики помесячные закажут
diag_sum = {}   # DFs с суммами по всем месяцам - для графика суммарных значений

for dog_type in dog_types:  # Индексы соответствуют названию договоров
    if dog_type in ('Роды', 'Ведение беременности', 'Госпитализация', 'Детство'):  # Обрабатываем только эти договоры
        # Готовим DataFrame'ы
        diag_full[dog_type] = pd.DataFrame(index=list(dog_quantity.keys()), columns=months,
                                           dtype=int)  # Обрезаем колонки по длине cols
        diag_sum[dog_type] = pd.DataFrame(index=list(dog_quantity.keys()), columns=['Всего'],
                                          dtype=int)  # В суммарном - только одна колонка
        for year in dog_quantity.keys():  # Перебираем по годам (это ключи набора матриц) исходных DF, данными наполняем DataFrame'ы
            try:
                diag_full[dog_type].loc[year] = dog_quantity[year].astype(dtype=int, copy=True).loc[
                    dog_type]  # [:len(cols)] # Это помесячный фрейм
                diag_sum[dog_type].loc[year] = sum(dog_quantity[year].astype(dtype=int, copy=True).loc[
                                                  dog_type])  # [:len(cols)])   # Это фрейм итоговых сумм
            except KeyError:  # не во всех файлах есть все типы договоров
                pass
        print(f'\nContract type: {dog_type}')
        print(diag_sum[dog_type])

        diag_sum[dog_type].plot.line()  # Подготавливаем линейный график
        # gr[i].transpose().plot.bar(stacked=True)  # Пробовал - не понравилось...
        plt.title(label=f'Договоры "{dog_type}", годы с {diag_sum[dog_type].index[0]} по {diag_sum[dog_type].index[-1]}.')
        plt.show()  # Рисуем
